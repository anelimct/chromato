---
title: "stage_M2"
format: html
editor: visual
---

```{r}
targets::tar_source(here::here("R/internship_analysis.R"))
targets::tar_load(imputed.traits_3T)
targets::tar_load(DB_bvocs_iso_mono_EF)
targets::tar_load(tree)


merged_data_3T <-merge_trait_EF(imputed.traits_3T, DB_bvocs_iso_mono_EF)
imputed.traits_3T <- subset(imputed.traits_3T, select = -SeedMass)
imputed.traits <-  imputed.traits_3T
funspaceDim(imputed.traits) #3 dimensions
imputed.traitsN <- normaliser_dataframe(imputed.traits)
pca.trait <- princomp(imputed.traitsN, cor=TRUE)
summary(pca.trait)
trait_space_global <- funspace(pca.trait, PCs=c(2,3), group.vec = merged_data_3T$BVOCsData)



merged_data_3T <- merge(merged_data_3T, trait_space_global$PCAInfo$pca.object$scores, by = "row.names", all.x = TRUE)%>% 
  column_to_rownames(var = "Row.names")



```

```{r}
TPD <- trait_space_global$global$images$noThreshold.quantiles |>
  reshape2::melt()|> 
  rename(PC2 = Var1) |> 
  rename(PC3 = Var2) 
```

```{r}
fig <- autoplot(pca.trait, 
                col = "transparent",  
                loadings = T,                                                                                                                                                                   
                loadings.colour = "grey50", 
                loadings.label = T, 
                loadings.label.colour = "grey50", 
                loadings.label.repel = T) 
```

```{r}
# Pour PC2-PC3 avec tuiles et points

trait_space_global <- funspace(pca.trait, PCs=c(2,3), group.vec = merged_data_3T$BVOCsData)
TPD <- trait_space_global$global$images$noThreshold.quantiles |>
  reshape2::melt()|> 
  rename(PC2 = Var1) |> 
  rename(PC3 = Var2) 
filtered_TPD <- TPD |> 
  filter((min(merged_data_3T$Comp.2) - 1) < PC2 & PC2 < (max(merged_data_3T$Comp.2) + 1)) |>
  filter((min(merged_data_3T$Comp.3) - 1) < PC3 & PC3 < (max(merged_data_3T$Comp.3) + 1))

contour_levels <- quantile(filtered_TPD$value, probs = c(0,0.1, 0.5))
viridis_colors <- c("#da6484","#3764da", "#70c230" ,"#FDE725FF")

type_labels <- c("both" = "Both", "iso" = "Isoprene", "mono" ="Monoterpenes", "NE" ="NE")

fig2_1 <- ggplot(data = TPD |> 
                   filter((min(merged_data_3T$Comp.2) - 1) < PC2 & 
                            PC2 < (max(merged_data_3T$Comp.2) + 1)) |>
                   filter((min(merged_data_3T$Comp.3) - 1) < PC3 & 
                            PC3 < (max(merged_data_3T$Comp.3) + 1))) +
  geom_tile(aes(x = PC2, y = PC3, fill = value), alpha = 0.3) +
  scale_fill_gradientn(colors = c("red", "orange", "yellow", "white"), 
                       values = scales::rescale(c(0, 0.5, 0.95, 0.99)), 
                       name = "Quantile Space", 
                       na.value = "white") +
  geom_contour(aes(x = PC2, y = PC3, z = value), color = "black", alpha = 0.3, 
               breaks = contour_levels) +
  ggnewscale::new_scale_fill() +
  geom_point(data = merged_data_3T|> 
               filter(BVOCsData == "1"),
             shape = 21, colour = "black",
             aes(x = Comp.2, y = Comp.3,  fill = type, size = Sum))+
  scale_size_continuous(range = c(1.5, 10), name = expression(EF[iso+mono]))+
  scale_fill_manual(name = "Emitter Type", values = c("both" = viridis_colors[1],
                                                      "iso" = viridis_colors[3], "mono" = viridis_colors[2], 
                                                      "NE" = viridis_colors[4]), labels = type_labels) +
  geom_hline(yintercept = 0, linetype = "dotted", color = "black") +
  geom_vline(xintercept = 0, linetype = "dotted", color = "black")+
  theme_minimal() +
  theme(
    plot.background = element_rect(fill = "white", color = NA))

# Pour PC2-PC3 avec flèches
arrows <- trait_space_global$PCAInfo$fit$arrows

offset <- 0.2
large_offset <- 0.4

fig2_2 <- ggplot(data = TPD |> 
                   filter((min(merged_data_3T$Comp.2) - 1) < PC2 & 
                            PC2 < (max(merged_data_3T$Comp.2) + 1)) |>
                   filter((min(merged_data_3T$Comp.3) - 1) < PC3 & 
                            PC3 < (max(merged_data_3T$Comp.3) + 1))) +
  geom_tile(aes(x = PC2, y = PC3), fill = NA, color = NA , alpha = 0) + # Fond blanc
  geom_segment(data = arrows, aes(x = 0, y = 0, xend = Comp.2, yend = Comp.3),
               arrow = arrow(type = "closed", angle = 20, length = unit(0.15, "inches")), color = "black") +
  geom_text(data = arrows, aes(x = Comp.2 + sign(Comp.2) * offset, y = Comp.3 + sign(Comp.3) * large_offset, label = rownames(arrows)), vjust = "inward" , hjust = "inward", color = "black", size = 5) + # Ajouter les noms des variables avec ajustement pour rester dans la figure
  ggnewscale::new_scale_fill() +
  geom_hline(yintercept = 0, linetype = "dotted", color = "black") +
  geom_vline(xintercept = 0, linetype = "dotted", color = "black") +
  theme_minimal()

# Pour PC1-PC2 avec tuiles et points
trait_space_global <- funspace(pca.trait, PCs = c(1, 2), group.vec = merged_data_3T$BVOCsData)

TPD <- trait_space_global$global$images$noThreshold.quantiles |>
  reshape2::melt() |>
  rename(PC1 = Var1) |>
  rename(PC2 = Var2)

filtered_TPD <- TPD |> 
                   filter((min(merged_data_3T$Comp.1) - 1) < PC1 & 
                            PC1 < (max(merged_data_3T$Comp.1) + 1)) |>
                   filter((min(merged_data_3T$Comp.2) - 1) < PC2 & 
                            PC2 < (max(merged_data_3T$Comp.2) + 1))

contour_levels <- quantile(filtered_TPD$value, probs = c(0,0.1, 0.5))



fig2_3 <- ggplot(data = TPD |> 
                   filter((min(merged_data_3T$Comp.1) - 1) < PC1 & 
                            PC1 < (max(merged_data_3T$Comp.1) + 1)) |>
                   filter((min(merged_data_3T$Comp.2) - 1) < PC2 & 
                            PC2 < (max(merged_data_3T$Comp.2) + 1))) +
  geom_tile(aes(x = PC1, y = PC2, fill = value), alpha = 0.3) +
  scale_fill_gradientn(colors = c("red", "orange", "yellow", "white"), 
                       values = scales::rescale(c(0, 0.5, 0.95, 0.99)), 
                       name = "Quantile Space", 
                       na.value = "white") +
  geom_contour(aes(x = PC1, y = PC2, z = value), color = "black", alpha = 0.3, 
               breaks = contour_levels) +
  ggnewscale::new_scale_fill() +
  geom_point(data = merged_data_3T|> 
               filter(BVOCsData == "1"),
             shape = 21, colour = "black",
             aes(x = Comp.1, y = Comp.2,  fill = type, size = Sum))+
  scale_size_continuous(range = c(1.5, 10), name = "Isoprenoids emission rate")+
  scale_fill_manual(name = "Emitter Type", values = c("both" = viridis_colors[1],
                                                      "iso" = viridis_colors[3], "mono" = viridis_colors[2], 
                                                      "NE" = viridis_colors[4]), labels = type_labels) +
  geom_hline(yintercept = 0, linetype = "dotted", color = "black") +
  geom_vline(xintercept = 0, linetype = "dotted", color = "black")+
  theme_minimal() +
  theme(
    plot.background = element_rect(fill = "white", color = NA))

# Pour PC1-PC2 avec flèches
arrows <- trait_space_global$PCAInfo$fit$arrows
fig2_4 <- ggplot(data = TPD |> 
                   filter((min(merged_data_3T$Comp.1) - 1) < PC1 & 
                            PC1 < (max(merged_data_3T$Comp.1) + 1)) |>
                   filter((min(merged_data_3T$Comp.2) - 1) < PC2 & 
                            PC2 < (max(merged_data_3T$Comp.2) + 1))) +
  geom_tile(aes(x = PC1, y = PC2), fill = NA, color = NA, alpha = 555) + # Fond blanc
  geom_segment(data = arrows, aes(x = 0, y = 0, xend = Comp.1, yend = Comp.2),
               arrow = arrow(type = "closed", angle = 20, length = unit(0.15, "inches")), color = "black") +
  geom_text(data = arrows, aes(x = Comp.1 + sign(Comp.1) * 0.4, y = Comp.2 + sign(Comp.2) * 0.4, label = rownames(arrows)), vjust = 0.5, hjust = 0.5, color = "black", size =5) + # Ajouter les noms des variables avec ajustement pour rester dans la figure
  ggnewscale::new_scale_fill() +
  geom_hline(yintercept = 0, linetype = "dotted", color = "black") +
  geom_vline(xintercept = 0, linetype = "dotted", color = "black") +
  theme_minimal() 

# Pour PC1-PC3 avec tuiles et points

trait_space_global <- funspace(pca.trait, PCs = c(1, 3), group.vec = merged_data_3T$BVOCsData)
TPD <- trait_space_global$global$images$noThreshold.quantiles |>
  reshape2::melt() |>
  rename(PC1 = Var1) |>
  rename(PC3 = Var2)


filtered_TPD <- TPD |> 
                   filter((min(merged_data_3T$Comp.1) - 1) < PC1 & 
                            PC1 < (max(merged_data_3T$Comp.1) + 1)) |>
                   filter((min(merged_data_3T$Comp.3) - 1) < PC3 & 
                            PC3 < (max(merged_data_3T$Comp.3) + 1))

contour_levels <- quantile(filtered_TPD$value, probs = c(0,0.1, 0.5))


fig2_5 <- ggplot(data = TPD |> 
                   filter((min(merged_data_3T$Comp.1) - 1) < PC1 & 
                            PC1 < (max(merged_data_3T$Comp.1) + 1)) |>
                   filter((min(merged_data_3T$Comp.3) - 1) < PC3 & 
                            PC3 < (max(merged_data_3T$Comp.3) + 1))) +
  geom_tile(aes(x = PC1, y = PC3, fill = value), alpha = 0.3) +
  scale_fill_gradientn(colors = c("red", "orange", "yellow", "white"), 
                       values = scales::rescale(c(0, 0.5, 0.95, 0.99)), 
                       name = "Quantile Space", 
                       na.value = "white") +
  geom_contour(aes(x = PC1, y = PC3, z = value), color = "black", alpha = 0.3, 
               breaks = contour_levels) +
  ggnewscale::new_scale_fill() +
  geom_point(data = merged_data_3T|> 
               filter(BVOCsData == "1"),
             shape = 21, colour = "black",
             aes(x = Comp.1, y = Comp.3,  fill = type, size = Sum))+
  scale_size_continuous(range = c(1.5, 10), name = "Isoprenoids emission rate")+
  scale_fill_manual(name = "Emitter Type", values = c("both" = viridis_colors[1],
                                                      "iso" = viridis_colors[3], "mono" = viridis_colors[2], 
                                                      "NE" = viridis_colors[4]), labels = type_labels) +
  geom_hline(yintercept = 0, linetype = "dotted", color = "black") +
  geom_vline(xintercept = 0, linetype = "dotted", color = "black")+
  theme_minimal() +
  theme(
    plot.background = element_rect(fill = "white", color = NA))

# Pour PC1-PC3 avec flèches
arrows <- trait_space_global$PCAInfo$fit$arrows
offset <- 0.2
large_offset <- 0.4

fig2_6 <- ggplot(data = TPD |> 
                   filter((min(merged_data_3T$Comp.1) - 1) < PC1 & 
                            PC1 < (max(merged_data_3T$Comp.1) + 1)) |>
                   filter((min(merged_data_3T$Comp.3) - 1) < PC3 & 
                            PC3 < (max(merged_data_3T$Comp.3) + 1))) +
  geom_tile(aes(x = PC1, y = PC3), fill = NA, color = NA, alpha = 555) + # Fond blanc
  geom_segment(data = arrows, aes(x = 0, y = 0, xend = Comp.1, yend = Comp.3),
               arrow = arrow(type = "closed", angle = 20, length = unit(0.15, "inches")), color = "black") +
  geom_text(data = arrows, aes(x = Comp.1 + sign(Comp.1) * 0.4, y = Comp.3 + sign(Comp.3) * 0.4 , label = rownames(arrows)), vjust = 0.5, hjust = 0.5, color = "black", size=5, position = position_dodge(width=1)) + # Ajouter les noms des variables avec ajustement pour rester dans la figure
  ggnewscale::new_scale_fill() +
  geom_hline(yintercept = 0, linetype = "dotted", color = "black") +
  geom_vline(xintercept = 0, linetype = "dotted", color = "black") +
  theme_minimal()
# Créer un cowplot avec les 6 graphiques
final_plot <- plot_grid(fig2_1, fig2_2, fig2_3, fig2_4, fig2_5, fig2_6, 
                        ncol = 2, 
                        labels = c("A", "B", "C", "D", "E", "F"), 
                        label_size = 12)

# Sauvegarder le cowplot
ggsave("final_cowplot.png", plot = final_plot, width = 420, height = 297, units = "mm", dpi = 300)

```

```{r}
# Charger les bibliothèques nécessaires
library(ggplot2)
library(cowplot)

# Charger les graphiques
plot6 <- ggplot2::ggplotGrob(fig2_1)  # PC2 vs PC3 avec tuiles et points
plot5 <- ggplot2::ggplotGrob(fig2_2)  # PC2 vs PC3 avec flèches
plot2 <- ggplot2::ggplotGrob(fig2_3)  # PC1 vs PC2 avec tuiles et points
plot1 <- ggplot2::ggplotGrob(fig2_4)  # PC1 vs PC2 avec flèches
plot4 <- ggplot2::ggplotGrob(fig2_5)  # PC1 vs PC3 avec tuiles et points
plot3 <- ggplot2::ggplotGrob(fig2_6)  # PC1 vs PC3 avec flèches

# Créer un cowplot avec les 6 graphiques
final_plot <- plot_grid(plot1, plot2, plot3, plot4, plot5, plot6, 
                        ncol = 2, 
                        labels = c("A", "B", "C", "D", "E", "F"), 
                        label_size = 12)

# Sauvegarder le cowplot
ggsave("final_cowplot.png", plot = final_plot, width = 420, height = 297, units = "mm", dpi = 300)

```

```{r}
get_legend <- function(my_ggplot) {
  tmp <- ggplotGrob(my_ggplot)
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend)
}

# Modifier fig2_1 pour avoir une légende horizontale avec des points plus grands
fig2_1 <- fig2_1 + 
  theme(legend.position = "bottom", 
        legend.box = "horizontal", 
        legend.text = element_text(size = 10)) +  # Modifier la taille du texte ici
  guides(fill = guide_legend(override.aes = list(size = 5)))

# Extraire la légende de fig2_1
legend <- get_legend(fig2_1)

# Supprimer les légendes des graphiques individuels
fig2_1 <- fig2_1 + theme(legend.position = "none")
fig2_3 <- fig2_3 + theme(legend.position = "none")
fig2_5 <- fig2_5 + theme(legend.position = "none")

# Créer un cowplot avec les 6 graphiques sans légende
plot_grid_no_legend <- plot_grid(fig2_3, fig2_4, fig2_5, fig2_6, fig2_1, fig2_2, 
                                 ncol = 2, 
                                 labels = c("A", "B", "C", "D", "E", "F"), 
                                 label_size = 12)

# Ajouter la légende en bas
final_plot <- plot_grid(plot_grid_no_legend, legend, ncol = 1, rel_heights = c(1, 0.1))


# Sauvegarder le cowplot final
ggsave("final_cowplot.png", plot = final_plot, width = 270, height = 357, units = "mm", dpi = 300)
```
